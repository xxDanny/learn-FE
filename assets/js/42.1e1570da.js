(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{1089:function(s,t,a){"use strict";a.r(t);var n=a(3),e=Object(n.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"详解-javascript-中的-event-loop-机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#详解-javascript-中的-event-loop-机制"}},[s._v("#")]),s._v(" 详解 JavaScript 中的 Event Loop 机制")]),s._v(" "),t("p",[s._v("我们都知道，javascript 从诞生之日起就是一门单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：与浏览器交互。")]),s._v(" "),t("p",[s._v("单线程意味着，javascript 代码在执行的任何时候，都只有一个主线程来处理所有的任务。\n而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如 I/O 事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。")]),s._v(" "),t("p",[s._v("单线程是必要的，也是 javascript 这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的 dom 操作。试想一下 如果 javascript 是多线程的，那么当两个线程同时对 dom 进行一项操作，例如一个向其添加事件，而另一个删除了这个 dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript 选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。")]),s._v(" "),t("p",[s._v("当然，现如今人们也意识到，单线程在保证了执行顺序的同时也限制了 javascript 的效率，因此开发出了 "),t("code",[s._v("web worker")]),s._v(" 技术。这项技术号称让 javascript 成为一门多线程语言。")]),s._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"title"},[s._v("web worker 限制")]),t("p",[s._v("然而，使用 web worker 技术开的多线程有着诸多限制，例如：所有新线程都受主线程的完全控制，不能独立执行。这意味着这些“线程” 实际上应属于主线程的子线程。另外，这些子线程并没有执行 I/O 操作的权限，只能为主线程分担一些诸如计算等任务")])]),t("p",[s._v("话说回来，前面提到 javascript 的另一个特点是“非阻塞”，那么 javascript 引擎到底是如何实现的这一点呢？答案就是今天这篇文章的主角——event loop（事件循环）。")]),s._v(" "),t("blockquote",[t("p",[s._v("虽然 nodejs 中的也存在与传统浏览器环境下的相似的事件循环。然而两者间却有着诸多不同，故把两者分开，单独解释。")])]),s._v(" "),t("h2",{attrs:{id:"浏览器环境下-javascript-引擎的事件循环机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器环境下-javascript-引擎的事件循环机制"}},[s._v("#")]),s._v(" 浏览器环境下 javascript 引擎的事件循环机制")]),s._v(" "),t("h3",{attrs:{id:"_1-执行栈与事件队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-执行栈与事件队列"}},[s._v("#")]),s._v(" 1. 执行栈与事件队列")]),s._v(" "),t("p",[s._v("当 javascript 代码执行的时候会将不同的变量存于内存中的不同位置： "),t("code",[s._v("堆（heap）")]),s._v(" 和 "),t("code",[s._v("栈（stack")]),s._v(" ）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。")]),s._v(" "),t("p",[s._v("我们知道，当我们调用一个方法的时候，js 会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的 this 对象。 而当一系列方法被依次调用的时候，因为 js 是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为"),t("strong",[s._v("执行栈")]),s._v("。")]),s._v(" "),t("p",[s._v("当一个脚本第一次执行的时候，js 引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么 js 会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js 会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。")]),s._v(" "),t("p",[s._v("下面这个图片非常直观的展示了这个过程，其中的 global 就是初次运行脚本时向执行栈中加入的代码：\n"),t("img",{attrs:{src:a(556),alt:""}})]),s._v(" "),t("p",[s._v("从图片可知，一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。")]),s._v(" "),t("p",[s._v("以上的过程说的都是同步代码的执行。那么当一个异步代码（如发送 ajax 请求数据）执行后会如何呢？前文提过，js 的另一大特点是非阻塞，实现这一点的关键在于下面要说的这项机制——事件队列（Task Queue）")]),s._v(" "),t("p",[s._v("js 引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js 会将这个事件加入与当前执行栈不同的另一个队列，我们称之为"),t("strong",[s._v("事件队列")]),s._v("。被放入事件队列不会立刻执行其回调，而是等待当前"),t("strong",[s._v("执行栈")]),s._v("中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找"),t("strong",[s._v("事件队列")]),s._v("是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入"),t("strong",[s._v("执行栈")]),s._v("中，然后执行其中的同步代码。..，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。")]),s._v(" "),t("p",[s._v("这里还有一张图来展示这个过程：\n"),t("img",{attrs:{src:a(557),alt:""}})]),s._v(" "),t("p",[s._v("图中的 "),t("code",[s._v("stack")]),s._v(" 表示我们所说的执行栈， "),t("code",[s._v("web apis")]),s._v(" 则是代表一些异步事件，而 "),t("code",[s._v("callback queue")]),s._v(" 即事件队列。")]),s._v(" "),t("h2",{attrs:{id:"macro-task-与-micro-task"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#macro-task-与-micro-task"}},[s._v("#")]),s._v(" macro task 与 micro task")]),s._v(" "),t("p",[s._v("以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。")]),s._v(" "),t("p",[s._v("以下事件属于宏任务：")]),s._v(" "),t("ul",[t("li",[s._v("包括整体代码 script")]),s._v(" "),t("li",[s._v("setInterval()")]),s._v(" "),t("li",[s._v("setTimeout()")])]),s._v(" "),t("p",[s._v("以下事件属于微任务")]),s._v(" "),t("ul",[t("li",[s._v("new Promise()")]),s._v(" "),t("li",[s._v("process.nextTick")]),s._v(" "),t("li",[s._v("new MutaionObserver()")])]),s._v(" "),t("p",[s._v("前面我们介绍过，在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的"),t("strong",[s._v("宏任务队列")]),s._v("或者"),t("strong",[s._v("微任务队列")]),s._v("中去。并且在当前"),t("strong",[s._v("执行栈")]),s._v("为空的时候，主线程会查看"),t("strong",[s._v("微任务队列")]),s._v("是否有事件存在。如果不存在，那么再去"),t("strong",[s._v("宏任务队列")]),s._v("中取出一个事件并把对应的回到加入当前"),t("strong",[s._v("执行栈")]),s._v("；如果存在，则会依次执行"),t("strong",[s._v("微任务队列")]),s._v("中事件对应的回调，直到"),t("strong",[s._v("微任务队列")]),s._v("为空，然后去"),t("strong",[s._v("宏任务队列")]),s._v("中取出最前面的一个事件，把对应的回调加入当前执行栈。.. 如此反复，进入循环。")]),s._v(" "),t("p",[s._v("我们只需记住当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。")]),s._v(" "),t("p",[s._v("这样就能解释下面这段代码的结果：")]),s._v(" "),t("div",{staticClass:"language-JS line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[s._v("setTimeout")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  console"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Promise")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("resolve"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" reject")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  console"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("resolve")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("then")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("val")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  console"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("val"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br")])]),t("p",[s._v("结果为")]),s._v(" "),t("div",{staticClass:"language-JS line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("h2",{attrs:{id:"node-环境下的事件循环机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-环境下的事件循环机制"}},[s._v("#")]),s._v(" node 环境下的事件循环机制")]),s._v(" "),t("ol",[t("li",[s._v("与浏览器环境有何不同？\n在 node 中，事件循环表现出的状态与浏览器中大致相同。不同的是 node 中有一套自己的模型。node 中事件循环的实现是依靠的 libuv 引擎。我们知道 node 选择 chrome v8 引擎作为 js 解释器，v8 引擎将 js 代码分析后去调用对应的 node api，而这些 api 最后则由 libuv 引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上 node 中的事件循环存在于 libuv 引擎中。")])]),s._v(" "),t("p",[t("img",{attrs:{src:a(558),alt:""}})]),s._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[s._v("#")]),s._v(" 参考")]),s._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://segmentfault.com/a/1190000038928521",target:"_blank",rel:"nofollow noopener noreferrer"}},[s._v("js 事件循环机制 event-loop"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=e.exports},556:function(s,t,a){s.exports=a.p+"assets/img/img1.2f761eb8.gif"},557:function(s,t,a){s.exports=a.p+"assets/img/img2.304d9356.png"},558:function(s,t,a){s.exports=a.p+"assets/img/img3.2e740aa0.png"}}]);