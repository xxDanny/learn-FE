(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{1102:function(t,a,s){"use strict";s.r(a);var r=s(3),n=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"最小生成树算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最小生成树算法"}},[t._v("#")]),t._v(" 最小生成树算法")]),t._v(" "),a("h2",{attrs:{id:"生成树的定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生成树的定义"}},[t._v("#")]),t._v(" 生成树的定义")]),t._v(" "),a("p",[t._v("一个连通图的生成树是一个极小的连通子图，它包含图中全部的 n 个顶点，但只有构成一棵树的 n-1 条边。")]),t._v(" "),a("p",[a("img",{attrs:{src:s(591),alt:""}}),t._v("\n可以看到一个包含 3 个顶点的完全图可以产生 3 颗生成树。对于包含 n 个顶点的无向完全图最多包含 n^(n-2) 颗生成树。比如上图中包含 3 个顶点的无向完全图，生成树的个数为： 3^(3-2)")]),t._v(" "),a("h2",{attrs:{id:"最小生成树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最小生成树"}},[t._v("#")]),t._v(" 最小生成树")]),t._v(" "),a("p",[t._v("所谓一个 带权图 的最小生成树，就是原图中边的权值最小的生成树 ，所谓最小是指边的权值之和小于或者等于其它生成树的边的权值之和。\n"),a("img",{attrs:{src:s(592),alt:""}})]),t._v(" "),a("p",[t._v("最小生成树算法有很多，其中最经典的就是克鲁斯卡尔（Kruskal）算法和 普里姆（Prim）算法，也是我们考试、面试当中经常遇到的两个算法。")]),t._v(" "),a("h2",{attrs:{id:"kruskal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kruskal"}},[t._v("#")]),t._v(" Kruskal")]),t._v(" "),a("p",[t._v("克鲁斯卡尔算法（Kruskal）是一种使用贪婪方法的最小生成树算法。 该算法初始将图视为森林，图中的每一个顶点视为一棵单独的树。 一棵树只与它的邻接顶点中权值最小且不违反最小生成树属性（不构成环）的树之间建立连边。")]),t._v(" "),a("h2",{attrs:{id:"prim-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prim-算法"}},[t._v("#")]),t._v(" Prim 算法")])])}),[],!1,null,null,null);a.default=n.exports},591:function(t,a,s){t.exports=s.p+"assets/img/1.4818a2a7.png"},592:function(t,a,s){t.exports=s.p+"assets/img/2.c874a05c.png"}}]);