(window.webpackJsonp=window.webpackJsonp||[]).push([[158],{1152:function(t,s,a){"use strict";a.r(s);var e=a(3),n=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"生命周期和模板引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生命周期和模板引用"}},[t._v("#")]),t._v(" 生命周期和模板引用")]),t._v(" "),s("h2",{attrs:{id:"vue-生命周期函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-生命周期函数"}},[t._v("#")]),t._v(" vue 生命周期函数")]),t._v(" "),s("ol",[s("li",[t._v("beforeCreate ：创建一个空白 vue 实例。data，method 尚未初始化，不可使用")]),t._v(" "),s("li",[t._v("created：vue 实例创建完毕，完成响应式绑定，尚未开始渲染。data，method 初始化完成，可调用。这里可以处理 js 相关的事务，但是不能处理 dom。")]),t._v(" "),s("li",[t._v("beforeMount：编译模版，调用 render 生成 vdom，还没有渲染 dom")]),t._v(" "),s("li",[t._v("mounted：完成的 dom 渲染，组件创建完成。由 创建 阶段进入运行阶段")]),t._v(" "),s("li",[t._v("beforeUpdate：data 发生变化之后，准备更新 dom（尚未更新 dom）")]),t._v(" "),s("li",[t._v("updated：更新了 dom")]),t._v(" "),s("li",[t._v("beforeUnmount：组件进入销毁阶段，可以移除一些全局事件，自定义时间")]),t._v(" "),s("li",[t._v("unmounted: 组件销毁了")])]),t._v(" "),s("h3",{attrs:{id:"vue-什么时候操作-dom-合适"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-什么时候操作-dom-合适"}},[t._v("#")]),t._v(" vue 什么时候操作 dom 合适")]),t._v(" "),s("p",[t._v("mounted 和 updated 不能保证子组件全部挂载完成\n使用 $nextTick 渲染 DOM")]),t._v(" "),s("div",{staticClass:"language-JS line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("mounted")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("$nextTick")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 整个视图被渲染完成后才厚执行")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("h3",{attrs:{id:"ajax-适合在那个生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ajax-适合在那个生命周期"}},[t._v("#")]),t._v(" Ajax 适合在那个生命周期")]),t._v(" "),s("ol",[s("li",[t._v("有两个选择：created 和 mounted")])]),t._v(" "),s("p",[t._v("推荐 mounted")]),t._v(" "),s("h3",{attrs:{id:"vue3-生命周期函数有什么不同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue3-生命周期函数有什么不同"}},[t._v("#")]),t._v(" VUE3 生命周期函数有什么不同")]),t._v(" "),s("ol",[s("li",[t._v("使用 setup 代替了 beforeCreated 和 created")]),t._v(" "),s("li",[t._v("使用 hooks 代替了 mounted（）")])]),t._v(" "),s("h3",{attrs:{id:"浏览器和-nodejs-事件循环区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器和-nodejs-事件循环区别"}},[t._v("#")]),t._v(" 浏览器和 nodejs 事件循环区别")]),t._v(" "),s("p",[t._v("js 是单线程的无论浏览器还是 nodejs")]),t._v(" "),s("p",[t._v("JS 执行和 DOM 渲染是共用一个线程：异步就是解决方案")]),t._v(" "),s("p",[t._v("微任务是在下一轮 DOM 渲染之前执行，宏任务是在下一轮 DOM 渲染之后就执行")]),t._v(" "),s("p",[t._v("微任务： this.nextTick()，promise")]),t._v(" "),s("p",[t._v("同步代码执行，遇到异步函数，浏览器会把异步回调函数放在回调函数队列中，同步代码结束之后，通过事件循环机制访问回调函数队列，执行队列重的任务。执行完之后，event loop 继续监听有没有新的任务进入任务队列中")]),t._v(" "),s("p",[t._v("nodejs 也适用 es 语法，也有红任务和微任务，但是分不同类型，不同优先级")]),t._v(" "),s("p",[t._v("宏任务；")]),t._v(" "),s("ol",[s("li",[t._v("setTimeout")]),t._v(" "),s("li",[t._v("I/O 回调函数 - 处理网络，流，TCP 回调错误")]),t._v(" "),s("li",[t._v("Idle，prepare - 闲置状态（nodejs 使用）")]),t._v(" "),s("li",[t._v("poll 轮询 - 执行 poll 中 I/O 队列")]),t._v(" "),s("li",[t._v("check - 存储 setImmediate 回调")]),t._v(" "),s("li",[t._v("close callbacks - 关闭回调。如 socket.on（‘close’）")])]),t._v(" "),s("p",[t._v("微任务\nprocess.nextTick()\npromise，async/await")]),t._v(" "),s("h2",{attrs:{id:"虚拟-dom"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom"}},[t._v("#")]),t._v(" 虚拟 DOM")]),t._v(" "),s("p",[t._v("用 js 节点 模拟 dom 节点的数据，最开始是由 react 推出的")]),t._v(" "),s("p",[t._v("vue/react 价值：1. 组件化 2. 数据视图分离，数据驱动分离")]),t._v(" "),s("p",[t._v("之前需要用 js 手动操作 dom，很多繁琐的代码。 model 操作 view。js 只需要操作数据的变化就可以了。我们就你可以只关注业务数据，不用再关心 Dom 变化")]),t._v(" "),s("p",[t._v("如何实现数据驱动视图：VDOM")]),t._v(" "),s("p",[t._v("业务发生变化之后，会触发模版重新生成新的 Vdom，利用 diff 算法然后新旧 Vdom 进行对比，找出需要更新的点最后去更新 dom。")]),t._v(" "),s("p",[t._v("简化开发逻辑，简化了代码，更有利于沟通，开发，重构。")]),t._v(" "),s("p",[t._v("目前为止，Vue 为我们处理了所有的 DOM 更新，这要归功于响应性和声明式渲染。然而，有时我们也会不可避免地需要手动操作 DOM。")]),t._v(" "),s("p",[t._v("这时我们需要使用模板引用——也就是指向模板中一个 DOM 元素的 ref。我们需要通过这个特殊的 ref attribute 来实现模板引用：")]),t._v(" "),s("div",{staticClass:"language-HTML line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("p")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("ref")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("p"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("hello"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("p")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("此元素将作为 "),s("code",[t._v("this.$refs.p")]),t._v(" 暴露在 "),s("code",[t._v("this.$refs")]),t._v(" 上。然而，你只能在组件挂载之后访问它。")]),t._v(" "),s("p",[t._v("要在挂载之后执行代码，我们可以使用 mounted 选项：")]),t._v(" "),s("div",{staticClass:"language-JS line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("mounted")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此时组件已经挂载。")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("p",[t._v("这被称为生命周期钩子——它允许我们注册一个在组件的特定生命周期调用的回调函数。还有一些其他的钩子如 "),s("code",[t._v("created")]),t._v(" 和 "),s("code",[t._v("updated")]),t._v(" 。更多细节请查阅 "),s("a",{attrs:{href:"https://cn.vuejs.org/guide/essentials/lifecycle.html#lifecycle-diagram",target:"_blank",rel:"nofollow noopener noreferrer"}},[t._v("生命周期图示"),s("OutboundLink")],1),t._v("。")])])}),[],!1,null,null,null);s.default=n.exports}}]);